# Reusable Workflow: Deploy to Cloudflare (Full-Stack)
#
# This workflow handles full-stack deployment:
# 1. Job deploy-api: Provisions Neon DB + deploys Hono Worker
# 2. Job deploy: Builds frontend with API URL + deploys to Pages
#
# Secrets required:
# - CLOUDFLARE_API_TOKEN: Cloudflare API token with Pages + Workers permissions
# - CLOUDFLARE_ACCOUNT_ID: Cloudflare account ID
# - NEON_API_KEY: Neon API key for database provisioning
# - NEON_PROJECT_ID: Neon project ID
# - LUMEA_WEBHOOK_SECRET: Shared secret for webhook authentication
# - PROJECT_SECRETS: JSON with project environment variables (optional)
#
# Used for: react-ts-fullstack template (Vite + Hono on CF)

name: Deploy to Cloudflare (Full-Stack)

on:
  workflow_call:
    inputs:
      project_slug:
        description: 'Project slug for platform domain'
        required: true
        type: string
      lumea_project_id:
        description: 'Lumea Project ID'
        required: true
        type: string
      custom_domain:
        description: 'Custom domain to configure (optional)'
        required: false
        type: string
        default: ''
      app_target:
        description: 'App target for secrets filtering (web, api, all)'
        required: false
        type: string
        default: 'all'
      badge:
        description: 'Show "Built with Lumea" badge on deployed site (true/false)'
        required: false
        type: string
        default: 'true'
    secrets:
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ACCOUNT_ID:
        required: true
      NEON_API_KEY:
        required: true
      NEON_ORG_ID:
        required: true
      LUMEA_WEBHOOK_SECRET:
        required: true
      PROJECT_SECRETS:
        required: false

env:
  PLATFORM_DOMAIN: builtwithlumea.dev
  CLOUDFLARE_ZONE_ID: fd6d42c5b39e410ef8326140eafee409

jobs:
  # ============================================================================
  # Job 1: Deploy Backend (Cloudflare Workers + Neon DB)
  # ============================================================================
  deploy-api:
    runs-on: ubuntu-latest
    outputs:
      api_url: ${{ steps.deploy.outputs.api_url }}
      neon_project_name: ${{ steps.neon.outputs.neon_project_name }}
      worker_name: ${{ steps.deploy.outputs.worker_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Install Wrangler CLI
        run: npm install -g wrangler

      # --------------------------------------------------------------------
      # Neon Project Provisioning (Lazy - one project per app)
      # --------------------------------------------------------------------
      - name: Provision Neon Project
        id: neon
        run: |
          LUMEA_PROJECT_ID="${{ inputs.lumea_project_id }}"
          # Neon project name based on Lumea project ID
          NEON_PROJECT_NAME="lumea-${LUMEA_PROJECT_ID}"

          echo "Checking if Neon project $NEON_PROJECT_NAME exists..."

          # List existing projects in the organization
          # IMPORTANT: Must filter by org_id to find org projects, not personal projects
          PROJECTS=$(curl -s -X GET \
            "https://console.neon.tech/api/v2/projects?org_id=${{ secrets.NEON_ORG_ID }}" \
            -H "Authorization: Bearer ${{ secrets.NEON_API_KEY }}" \
            -H "Accept: application/json")

          echo "Found $(echo "$PROJECTS" | jq '.projects | length') projects in org"

          # Check if our project exists (by name) - take first match if duplicates exist
          NEON_PROJECT_ID=$(echo "$PROJECTS" | jq -r "[.projects[]? | select(.name == \"$NEON_PROJECT_NAME\")] | first | .id // empty")

          if [ -z "$NEON_PROJECT_ID" ]; then
            echo "Neon project does not exist, creating..."

            # Create new Neon project
            CREATE_RESULT=$(curl -s -X POST \
              "https://console.neon.tech/api/v2/projects" \
              -H "Authorization: Bearer ${{ secrets.NEON_API_KEY }}" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d "{
                \"project\": {
                  \"name\": \"$NEON_PROJECT_NAME\",
                  \"region_id\": \"aws-us-east-1\",
                  \"pg_version\": 17,
                  \"org_id\": \"${{ secrets.NEON_ORG_ID }}\"
                }
              }")

            # Check for errors
            ERROR=$(echo "$CREATE_RESULT" | jq -r '.message // empty')
            if [ -n "$ERROR" ]; then
              echo "::error::Failed to create Neon project: $ERROR"
              echo "$CREATE_RESULT"
              exit 1
            fi

            NEON_PROJECT_ID=$(echo "$CREATE_RESULT" | jq -r '.project.id // empty')

            if [ -z "$NEON_PROJECT_ID" ]; then
              echo "::error::Failed to get project ID from response"
              echo "$CREATE_RESULT"
              exit 1
            fi

            # Get connection URI from creation response
            DATABASE_URL=$(echo "$CREATE_RESULT" | jq -r '.connection_uris[0].connection_uri // empty')

            echo "âœ… Neon project created: $NEON_PROJECT_NAME (ID: $NEON_PROJECT_ID)"
            echo "is_new_project=true" >> $GITHUB_OUTPUT
          else
            echo "âœ… Neon project already exists: $NEON_PROJECT_NAME (ID: $NEON_PROJECT_ID)"
            echo "is_new_project=false" >> $GITHUB_OUTPUT

            # Get connection URI using dedicated endpoint (more reliable)
            # Default database is 'neondb', default role is 'neondb_owner'
            CONNECTION_RESULT=$(curl -s -X GET \
              "https://console.neon.tech/api/v2/projects/$NEON_PROJECT_ID/connection_uri?database_name=neondb&role_name=neondb_owner" \
              -H "Authorization: Bearer ${{ secrets.NEON_API_KEY }}" \
              -H "Accept: application/json")

            DATABASE_URL=$(echo "$CONNECTION_RESULT" | jq -r '.uri // empty')
          fi

          if [ -z "$DATABASE_URL" ]; then
            echo "::error::Could not get connection URI from Neon project"
            exit 1
          fi

          echo "neon_project_id=$NEON_PROJECT_ID" >> $GITHUB_OUTPUT
          echo "neon_project_name=$NEON_PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "database_url=$DATABASE_URL" >> $GITHUB_OUTPUT
          echo "::add-mask::$DATABASE_URL"

          echo "ðŸ“ Database URL retrieved successfully"

      # --------------------------------------------------------------------
      # Run Database Migrations / Push Schema
      # --------------------------------------------------------------------
      - name: Run Database Migrations
        working-directory: server
        run: |
          echo "Running database schema setup..."

          # Check if migration files exist
          MIGRATIONS_EXIST=false
          if [ -d "drizzle" ] && [ -f "drizzle/meta/_journal.json" ]; then
            MIGRATIONS_EXIST=true
          fi

          if [ -f "package.json" ]; then
            if [ "$MIGRATIONS_EXIST" = "true" ]; then
              # Migrations exist - run migrate
              echo "Migrations found, running migrate..."
              if grep -q '"db:migrate"' package.json; then
                bun run db:migrate
              elif grep -q '"migrate"' package.json; then
                bun run migrate
              else
                bunx drizzle-kit migrate
              fi
            else
              # No migrations - use push to apply schema directly
              echo "No migrations found, using db:push to apply schema..."
              if grep -q '"db:push"' package.json; then
                bun run db:push
              else
                bunx drizzle-kit push
              fi
            fi
          else
            echo "No package.json found in server/, skipping"
          fi

          echo "âœ… Database schema applied"
        env:
          DATABASE_URL: ${{ steps.neon.outputs.database_url }}

      # --------------------------------------------------------------------
      # Run Database Seed (only for new projects)
      # --------------------------------------------------------------------
      - name: Run Database Seed
        if: steps.neon.outputs.is_new_project == 'true'
        working-directory: server
        run: |
          echo "Running database seed (new project)..."

          # Check if seed script exists
          if [ -f "package.json" ]; then
            if grep -q '"db:seed"' package.json; then
              echo "Running: bun run db:seed"
              bun run db:seed
            elif grep -q '"seed"' package.json; then
              echo "Running: bun run seed"
              bun run seed
            else
              echo "No seed script found, skipping"
            fi
          else
            echo "No package.json found in server/, skipping seed"
          fi

          echo "âœ… Seed completed"
        env:
          DATABASE_URL: ${{ steps.neon.outputs.database_url }}

      # --------------------------------------------------------------------
      # Deploy Worker
      # --------------------------------------------------------------------
      - name: Deploy Worker
        id: deploy
        working-directory: server
        run: |
          # Use first 8 chars of project ID for uniqueness (standard UUID practice)
          # This keeps worker name under 54 char limit for CF previews
          PROJECT_ID="${{ inputs.lumea_project_id }}"
          PROJECT_ID_SHORT="${PROJECT_ID:0:8}"

          # Worker name: lumea-api-{slug}-{uuid8}
          # Max: 10 (lumea-api-) + 35 (slug) + 1 (-) + 8 (uuid) = 54 chars
          SLUG="${{ inputs.project_slug }}"

          # Truncate slug if needed to stay under 54 chars total
          MAX_SLUG_LEN=$((54 - 10 - 1 - 8))  # 35 chars max for slug
          if [ ${#SLUG} -gt $MAX_SLUG_LEN ]; then
            SLUG="${SLUG:0:$MAX_SLUG_LEN}"
          fi

          WORKER_NAME="lumea-api-${SLUG}-${PROJECT_ID_SHORT}"

          # Production URLs
          FRONTEND_URL="https://${SLUG}.${{ env.PLATFORM_DOMAIN }}"
          API_URL="https://api-${SLUG}-${PROJECT_ID_SHORT}.${{ env.PLATFORM_DOMAIN }}"

          echo "Deploying Worker: $WORKER_NAME (${#WORKER_NAME} chars)"
          echo "Frontend URL: $FRONTEND_URL"
          echo "API URL: $API_URL"

          # Deploy with wrangler and production environment variables
          npx wrangler deploy \
            --name "$WORKER_NAME" \
            --compatibility-date "2024-01-01" \
            --var NODE_ENV:production \
            --var LOG_LEVEL:info \
            --var CORS_ORIGINS:"$FRONTEND_URL" \
            --var BETTER_AUTH_URL:"$FRONTEND_URL" \
            2>&1 | tee deploy_output.txt

          # Check if deploy succeeded
          if [ $? -ne 0 ]; then
            echo "::error::Worker deployment failed"
            cat deploy_output.txt
            exit 1
          fi

          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "worker_name=$WORKER_NAME" >> $GITHUB_OUTPUT
          echo "project_id_short=$PROJECT_ID_SHORT" >> $GITHUB_OUTPUT

          echo "âœ… Worker deployed: $WORKER_NAME"
          echo "ðŸ“ API URL: $API_URL"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      # --------------------------------------------------------------------
      # Set Worker Secrets (DATABASE_URL + project secrets)
      # --------------------------------------------------------------------
      - name: Set Worker Secrets
        working-directory: server
        run: |
          WORKER_NAME="${{ steps.deploy.outputs.worker_name }}"

          echo "Setting DATABASE_URL secret..."
          echo "${{ steps.neon.outputs.database_url }}" | npx wrangler secret put DATABASE_URL --name "$WORKER_NAME"

          # Add any additional project secrets for API
          SECRETS='${{ secrets.PROJECT_SECRETS }}'
          if [ -n "$SECRETS" ] && [ "$SECRETS" != "" ]; then
            echo "Setting project secrets..."
            # Get api and all secrets
            echo "$SECRETS" | jq -r '
              ((.all // {}) + ((.api // {})))
              | to_entries[]
              | "\(.key)=\(.value)"
            ' | while IFS='=' read -r key value; do
              if [ -n "$key" ] && [ -n "$value" ]; then
                echo "Setting secret: $key"
                echo "$value" | npx wrangler secret put "$key" --name "$WORKER_NAME"
              fi
            done 2>/dev/null || true
          fi

          echo "âœ… Worker secrets configured"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      # --------------------------------------------------------------------
      # Configure Custom Domain for Worker
      # --------------------------------------------------------------------
      - name: Configure Worker Custom Domain
        run: |
          WORKER_NAME="${{ steps.deploy.outputs.worker_name }}"
          PROJECT_ID_SHORT="${{ steps.deploy.outputs.project_id_short }}"

          # Truncate slug same as in deploy step
          SLUG="${{ inputs.project_slug }}"
          MAX_SLUG_LEN=$((54 - 10 - 1 - 8))  # 35 chars max for slug
          if [ ${#SLUG} -gt $MAX_SLUG_LEN ]; then
            SLUG="${SLUG:0:$MAX_SLUG_LEN}"
          fi

          SUBDOMAIN="api-${SLUG}-${PROJECT_ID_SHORT}"
          FULL_DOMAIN="${SUBDOMAIN}.${{ env.PLATFORM_DOMAIN }}"

          echo "Configuring custom domain: $FULL_DOMAIN for worker: $WORKER_NAME"

          # Delete any existing CNAME record that might conflict
          # Workers Custom Domains manages DNS internally, so we don't need a CNAME
          EXISTING_DNS=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_ZONE_ID }}/dns_records?name=$FULL_DOMAIN" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json")

          RECORD_ID=$(echo "$EXISTING_DNS" | jq -r '.result[0].id // empty')

          if [ -n "$RECORD_ID" ]; then
            echo "Deleting existing DNS record to avoid CNAME cross-user conflict..."
            curl -s -X DELETE \
              "https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_ZONE_ID }}/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json"
            echo "Existing DNS record deleted"
          fi

          # Use Workers Custom Domains API (handles DNS automatically)
          # No CNAME needed - this avoids Error 1014 (CNAME Cross-User Banned)
          echo "Adding custom domain to worker via Workers Custom Domains API..."
          DOMAIN_RESULT=$(curl -s -X PUT \
            "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/workers/domains" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"environment\": \"production\",
              \"hostname\": \"$FULL_DOMAIN\",
              \"service\": \"$WORKER_NAME\",
              \"zone_id\": \"${{ env.CLOUDFLARE_ZONE_ID }}\"
            }")

          echo "$DOMAIN_RESULT"

          # Check if domain was added successfully
          DOMAIN_SUCCESS=$(echo "$DOMAIN_RESULT" | jq -r '.success // false')
          if [ "$DOMAIN_SUCCESS" = "true" ]; then
            echo "âœ… Custom domain configured: $FULL_DOMAIN"
          else
            ERROR_MSG=$(echo "$DOMAIN_RESULT" | jq -r '.errors[0].message // "Unknown error"')
            echo "::error::Custom domain configuration failed: $ERROR_MSG"
            exit 1
          fi
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      # --------------------------------------------------------------------
      # Notify Lumea on API deployment failure
      # --------------------------------------------------------------------
      - name: Notify Lumea (API Failure)
        if: failure()
        run: |
          curl -X POST "${{ vars.LUMEA_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -H "X-Webhook-Secret: ${{ secrets.LUMEA_WEBHOOK_SECRET }}" \
            -d '{
              "projectId": "${{ inputs.lumea_project_id }}",
              "status": "error",
              "error": "API deployment failed (Neon or Worker)",
              "workflowRunId": "${{ github.run_id }}",
              "logsUrl": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }'

  # ============================================================================
  # Job 2: Deploy Frontend (Cloudflare Pages)
  # ============================================================================
  deploy:
    runs-on: ubuntu-latest
    needs: deploy-api
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Setup Node.js (for Wrangler)
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: bun install

      - name: Install Wrangler CLI
        run: npm install -g wrangler

      - name: Create .env file from secrets
        run: |
          SECRETS='${{ secrets.PROJECT_SECRETS }}'
          TARGET="${{ inputs.app_target }}"

          # Start with API URL from deploy-api job
          echo "VITE_API_URL=${{ needs.deploy-api.outputs.api_url }}" > .env

          if [ -z "$SECRETS" ] || [ "$SECRETS" = "" ]; then
            echo "No project secrets configured, using only VITE_API_URL"
            exit 0
          fi

          echo "Creating .env file for target: $TARGET"

          # Combine "all" target with specific target (web)
          echo "$SECRETS" | jq -r "
            ((.all // {}) + (.[\"$TARGET\"] // {}) + (.web // {}))
            | to_entries[]
            | \"\(.key)=\(.value)\"
          " >> .env

          echo "Environment variables written to .env"

      - name: Inject Lumea Badge
        if: inputs.badge == 'true'
        continue-on-error: true
        run: |
          echo "Injecting Lumea badge into React app..."

          # Find the main index.html file
          INDEX_FILE=""
          if [ -f "apps/web/index.html" ]; then
            INDEX_FILE="apps/web/index.html"
          elif [ -f "index.html" ]; then
            INDEX_FILE="index.html"
          fi

          if [ -z "$INDEX_FILE" ]; then
            echo "No index.html found, skipping badge injection"
            exit 0
          fi

          echo "Found index file: $INDEX_FILE"

          # Add badge script before </body>
          if ! grep -q "lumea.dev/badge.js" "$INDEX_FILE"; then
            sed -i 's|</body>|<script src="https://lumea.dev/badge.js" data-project-id="${{ inputs.lumea_project_id }}" defer></script></body>|' "$INDEX_FILE"
            echo "Badge script injected"
          else
            echo "Badge script already present"
          fi

      - name: Build React App
        id: build
        run: |
          # Check if this is a monorepo with apps/web structure
          if [ -d "apps/web" ]; then
            echo "Detected monorepo structure, building apps/web..."
            cd apps/web
            bun run build
            echo "build_dir=apps/web/dist" >> $GITHUB_OUTPUT
          else
            echo "Building root project..."
            bun run build
            echo "build_dir=dist" >> $GITHUB_OUTPUT
          fi
        env:
          NODE_ENV: production
          VITE_API_URL: ${{ needs.deploy-api.outputs.api_url }}

      - name: Deploy to Cloudflare Pages
        id: pages_deploy
        run: |
          PROJECT_NAME="lumea-${{ inputs.project_slug }}"
          BUILD_DIR="${{ steps.build.outputs.build_dir }}"

          echo "Deploying $BUILD_DIR to Cloudflare Pages project: $PROJECT_NAME"

          # Create project if it doesn't exist (ignore error if exists)
          wrangler pages project create "$PROJECT_NAME" --production-branch=main 2>/dev/null || true

          # Deploy to Cloudflare Pages
          DEPLOY_OUTPUT=$(wrangler pages deploy "$BUILD_DIR" \
            --project-name="$PROJECT_NAME" \
            --branch=main \
            --commit-dirty=true 2>&1)

          echo "$DEPLOY_OUTPUT"

          # Extract deployment URL from output
          DEPLOYMENT_URL=$(echo "$DEPLOY_OUTPUT" | grep -oP 'https://[a-z0-9-]+\.pages\.dev' | head -1)

          if [ -z "$DEPLOYMENT_URL" ]; then
            # Try alternative pattern for custom domains
            DEPLOYMENT_URL=$(echo "$DEPLOY_OUTPUT" | grep -oP 'https://[^\s]+' | head -1)
          fi

          echo "deployment_url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT

          # Get the pages.dev domain
          PAGES_DOMAIN="${PROJECT_NAME}.pages.dev"
          echo "pages_domain=$PAGES_DOMAIN" >> $GITHUB_OUTPUT
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Configure Platform Domain
        id: platform_domain
        run: |
          PROJECT_NAME="${{ steps.pages_deploy.outputs.project_name }}"
          SUBDOMAIN="${{ inputs.project_slug }}.${{ env.PLATFORM_DOMAIN }}"

          echo "Adding platform subdomain: $SUBDOMAIN to project: $PROJECT_NAME"

          # Add platform subdomain to Cloudflare Pages project
          RESULT=$(curl -s -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/$PROJECT_NAME/domains" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{\"name\": \"$SUBDOMAIN\"}" 2>&1) || true

          echo "$RESULT"

          SUCCESS=$(echo "$RESULT" | jq -r '.success // false')
          if [ "$SUCCESS" = "true" ]; then
            echo "Platform subdomain added successfully"
          else
            echo "Platform subdomain may already be configured"
          fi

          echo "platform_domain=$SUBDOMAIN" >> $GITHUB_OUTPUT

      - name: Create DNS Record
        id: dns_record
        run: |
          SUBDOMAIN="${{ inputs.project_slug }}"
          PAGES_DOMAIN="${{ steps.pages_deploy.outputs.pages_domain }}"

          echo "Creating CNAME record: $SUBDOMAIN.${{ env.PLATFORM_DOMAIN }} â†’ $PAGES_DOMAIN"

          # Check if record already exists
          EXISTING=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_ZONE_ID }}/dns_records?type=CNAME&name=$SUBDOMAIN.${{ env.PLATFORM_DOMAIN }}" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json")

          RECORD_ID=$(echo "$EXISTING" | jq -r '.result[0].id // empty')

          if [ -n "$RECORD_ID" ]; then
            echo "Record exists (ID: $RECORD_ID), updating..."
            RESULT=$(curl -s -X PUT \
              "https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_ZONE_ID }}/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{\"type\":\"CNAME\",\"name\":\"$SUBDOMAIN\",\"content\":\"$PAGES_DOMAIN\",\"ttl\":1,\"proxied\":true}")
          else
            echo "Creating new record..."
            RESULT=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_ZONE_ID }}/dns_records" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{\"type\":\"CNAME\",\"name\":\"$SUBDOMAIN\",\"content\":\"$PAGES_DOMAIN\",\"ttl\":1,\"proxied\":true}")
          fi

          echo "$RESULT"

          SUCCESS=$(echo "$RESULT" | jq -r '.success // false')
          if [ "$SUCCESS" = "true" ]; then
            echo "âœ… DNS record created successfully"
          else
            echo "âš ï¸ DNS record creation failed"
          fi

      - name: Configure Custom Domain
        id: custom_domain
        if: inputs.custom_domain != ''
        run: |
          CUSTOM_DOMAIN="${{ inputs.custom_domain }}"
          PROJECT_NAME="${{ steps.pages_deploy.outputs.project_name }}"

          echo "Configuring custom domain: $CUSTOM_DOMAIN for project: $PROJECT_NAME"

          # Add custom domain to Cloudflare Pages project
          RESULT=$(curl -s -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/$PROJECT_NAME/domains" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{\"name\": \"$CUSTOM_DOMAIN\"}" 2>&1) || true

          echo "$RESULT"

          SUCCESS=$(echo "$RESULT" | jq -r '.success // false')

          if [ "$SUCCESS" = "true" ]; then
            echo "Custom domain added successfully"
            echo "custom_domain_verified=false" >> $GITHUB_OUTPUT
          else
            ERROR_CODE=$(echo "$RESULT" | jq -r '.errors[0].code // empty')
            if [ "$ERROR_CODE" = "1000" ]; then
              echo "Custom domain already configured"
              echo "custom_domain_verified=true" >> $GITHUB_OUTPUT
            else
              echo "Failed to add custom domain"
              echo "custom_domain_verified=false" >> $GITHUB_OUTPUT
            fi
          fi
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Notify Lumea (Success)
        if: success()
        run: |
          # Build webhook payload
          PAYLOAD=$(cat <<EOF
          {
            "projectId": "${{ inputs.lumea_project_id }}",
            "status": "ready",
            "deploymentUrl": "https://${{ steps.platform_domain.outputs.platform_domain }}",
            "apiUrl": "${{ needs.deploy-api.outputs.api_url }}",
            "workflowRunId": "${{ github.run_id }}",
            "commitSha": "${{ github.sha }}",
            "logsUrl": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "deploymentConfig": {
              "provider": "cloudflare",
              "type": "fullstack",
              "projectName": "${{ steps.pages_deploy.outputs.project_name }}",
              "pagesDomain": "${{ steps.pages_deploy.outputs.pages_domain }}",
              "workerName": "${{ needs.deploy-api.outputs.worker_name }}",
              "neonProjectName": "${{ needs.deploy-api.outputs.neon_project_name }}"
            }
          EOF
          )

          # Add custom domain info if configured
          if [ -n "${{ inputs.custom_domain }}" ]; then
            PAYLOAD="${PAYLOAD},
            \"customDomain\": \"${{ inputs.custom_domain }}\",
            \"customDomainVerified\": ${{ steps.custom_domain.outputs.custom_domain_verified || 'false' }}"
          fi

          PAYLOAD="${PAYLOAD}}"

          echo "Sending webhook to Lumea..."
          curl -X POST "${{ vars.LUMEA_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -H "X-Webhook-Secret: ${{ secrets.LUMEA_WEBHOOK_SECRET }}" \
            -d "$PAYLOAD"

      - name: Notify Lumea (Failure)
        if: failure()
        run: |
          curl -X POST "${{ vars.LUMEA_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -H "X-Webhook-Secret: ${{ secrets.LUMEA_WEBHOOK_SECRET }}" \
            -d '{
              "projectId": "${{ inputs.lumea_project_id }}",
              "status": "error",
              "error": "Build or deployment failed",
              "workflowRunId": "${{ github.run_id }}",
              "logsUrl": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }'
