# Reusable Workflow: Deploy to Expo Snack
#
# This workflow should be placed in the lumea-apps/workflows repository
# at .github/workflows/deploy-snack.yml
#
# It handles:
# 1. Creating/updating an Expo Snack from the repository
# 2. Calling the Lumea webhook with the Snack URL
#
# Secrets required:
# - EXPO_SESSION_SECRET: Expo session token for API authentication
# - LUMEA_WEBHOOK_SECRET: Shared secret for webhook authentication
#
# @see SHO-122 - Mobile Preview via Snack

name: Deploy to Snack

on:
  workflow_call:
    inputs:
      lumea_project_id:
        description: 'Lumea Project ID'
        required: true
        type: string
    secrets:
      EXPO_SESSION_SECRET:
        required: true
      LUMEA_WEBHOOK_SECRET:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Deploy to Expo Snack
        id: snack
        env:
          EXPO_SESSION_SECRET: ${{ secrets.EXPO_SESSION_SECRET }}
        run: |
          node --input-type=module << 'EOF'
          import fs from 'fs';
          import path from 'path';

          const SESSION_SECRET = process.env.EXPO_SESSION_SECRET;
          if (!SESSION_SECRET) {
            console.error('EXPO_SESSION_SECRET not set');
            process.exit(1);
          }

          const PROJECT_ROOT = process.cwd();
          const SNACK_RUNTIME_ID = '933fd9c0-1666-11e7-afca-d980795c5824';

          // Read SDK version from package.json (source of truth)
          let SDK_VERSION = '54.0.0'; // fallback only
          try {
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const expoVersion = pkg.dependencies?.expo || pkg.devDependencies?.expo;
            if (expoVersion) {
              // Extract version number: "~54.0.0" -> "54.0.0", "^53.0.0" -> "53.0.0"
              const match = expoVersion.match(/(\d+\.\d+\.\d+)/);
              if (match) {
                SDK_VERSION = match[1];
                console.log(`Detected Expo SDK version from package.json: ${SDK_VERSION}`);
              }
            }
          } catch (e) {
            console.warn('Could not read SDK version from package.json, using fallback:', SDK_VERSION);
          }

          // Read app name from package.json
          let appName = 'Lumea App';
          let appDescription = 'Built with Lumea';
          try {
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            appName = pkg.name || appName;
            appDescription = pkg.description || appDescription;
          } catch (e) {}

          // Patterns to ignore when scanning files
          const IGNORE_PATTERNS = [
            'node_modules', '.git', '.expo', 'dist', 'build', '.gitignore',
            'bun.lock', 'package-lock.json', 'yarn.lock',
            '.github', '__tests__', 'test', 'tests',
          ];

          // Supported file extensions
          const SUPPORTED_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.json'];

          // Files to exclude from code (handled separately or not needed)
          const EXCLUDE_FILES = ['package.json', 'package-lock.json', 'tsconfig.json'];

          function readFilesRecursively(dir, baseDir = dir) {
            const files = {};

            if (!fs.existsSync(dir)) return files;

            const entries = fs.readdirSync(dir, { withFileTypes: true });

            for (const entry of entries) {
              const fullPath = path.join(dir, entry.name);
              const relativePath = path.relative(baseDir, fullPath);

              if (IGNORE_PATTERNS.some(pattern => relativePath.includes(pattern))) continue;
              if (EXCLUDE_FILES.includes(entry.name)) continue;

              if (entry.isDirectory()) {
                Object.assign(files, readFilesRecursively(fullPath, baseDir));
              } else if (entry.isFile()) {
                const ext = path.extname(entry.name);
                if (SUPPORTED_EXTENSIONS.includes(ext)) {
                  try {
                    files[relativePath] = fs.readFileSync(fullPath, 'utf-8');
                  } catch (e) {
                    console.warn(`Warning: Could not read ${relativePath}`);
                  }
                }
              }
            }
            return files;
          }

          function prepareSnackFiles(files) {
            const snackFiles = {};

            // Handle App entry point
            const appEntryPoints = ['App.tsx', 'App.jsx', 'App.js', 'src/App.tsx', 'src/App.jsx', 'src/App.js'];
            let appEntryFound = false;

            for (const entry of appEntryPoints) {
              if (files[entry]) {
                let content = files[entry];
                // Normalize .jsx/.tsx imports to .js for Snack compatibility
                content = content.replace(/\.(jsx|tsx)(['"])/g, '.js$2');
                snackFiles['App.js'] = { type: 'CODE', contents: content };
                delete files[entry];
                appEntryFound = true;
                break;
              }
            }

            if (!appEntryFound) {
              console.warn('Warning: No App entry point found');
            }

            // Process remaining files
            for (const [filePath, content] of Object.entries(files)) {
              let snackPath = filePath;

              // Remove src/ prefix if present
              if (snackPath.startsWith('src/')) {
                snackPath = snackPath.replace('src/', '');
              }

              // Normalize extensions for Snack
              snackPath = snackPath.replace(/\.(jsx|tsx)$/, '.js');

              // Skip index/main entry files (App.js is the entry)
              if (snackPath === 'index.js' || snackPath === 'main.js') continue;

              snackFiles[snackPath] = {
                type: 'CODE',
                contents: content.replace(/\.(jsx|tsx)(['"])/g, '.js$2'),
              };
            }

            return snackFiles;
          }

          function getDependencies() {
            // Read ALL dependencies from package.json (source of truth)
            const deps = {};

            try {
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              const pkgDeps = { ...pkg.dependencies, ...pkg.devDependencies } || {};

              console.log('Reading dependencies from package.json...');

              for (const [name, version] of Object.entries(pkgDeps)) {
                // Skip dev-only tools that Snack doesn't need
                const skipPackages = [
                  '@types/', 'typescript', 'eslint', 'prettier',
                  '@babel/', 'metro', 'jest', '@testing-library'
                ];
                if (skipPackages.some(skip => name.includes(skip))) continue;

                // Clean version string (remove workspace:, file:, etc.)
                let cleanVersion = version;
                if (version.startsWith('workspace:') || version.startsWith('file:')) {
                  console.warn(`Skipping local dependency: ${name}@${version}`);
                  continue;
                }

                deps[name] = { version: cleanVersion, wantedVersion: cleanVersion };
              }

              console.log(`Found ${Object.keys(deps).length} dependencies:`);
              console.log(Object.keys(deps).join(', '));

            } catch (e) {
              console.error('Failed to read package.json:', e.message);
              // Minimal fallback only if package.json is completely missing
              return {
                'expo': { version: '~54.0.0', wantedVersion: '~54.0.0' },
                'react': { version: '18.3.1', wantedVersion: '18.3.1' },
                'react-native': { version: '0.76.9', wantedVersion: '0.76.9' },
              };
            }

            // Ensure core deps exist (Snack requires these)
            if (!deps['expo']) deps['expo'] = { version: '~54.0.0', wantedVersion: '~54.0.0' };
            if (!deps['react']) deps['react'] = { version: '18.3.1', wantedVersion: '18.3.1' };
            if (!deps['react-native']) deps['react-native'] = { version: '0.76.9', wantedVersion: '0.76.9' };

            return deps;
          }

          function getManifestDependencies(deps) {
            const manifestDeps = {};
            for (const [name, info] of Object.entries(deps)) {
              manifestDeps[name] = info.version;
            }
            return manifestDeps;
          }

          async function createSnack() {
            console.log('Reading project files...');

            const rawFiles = readFilesRecursively(PROJECT_ROOT);
            const code = prepareSnackFiles(rawFiles);
            const dependencies = getDependencies();

            console.log(`Found ${Object.keys(code).length} files to upload`);
            console.log(`Files: ${Object.keys(code).join(', ')}`);

            const payload = {
              manifest: {
                sdkVersion: SDK_VERSION,
                name: appName,
                description: appDescription,
                dependencies: getManifestDependencies(dependencies),
              },
              code: code,
              dependencies: dependencies,
              isDraft: false,
              save: true,
            };

            console.log('Uploading to Snack API...');

            const response = await fetch('https://exp.host/--/api/v2/snack/save', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Expo-Session': SESSION_SECRET,
              },
              body: JSON.stringify(payload),
            });

            const result = await response.json();

            if (result.id || result.hashId) {
              const snackId = result.id || result.hashId;
              const webUrl = `https://snack.expo.dev/${snackId}`;
              const expoGoUrl = `exp://u.expo.dev/${SNACK_RUNTIME_ID}?runtime-version=exposdk:${SDK_VERSION}&channel-name=production&snack=${snackId}`;

              console.log('');
              console.log('Snack deployed successfully!');
              console.log(`Web URL: ${webUrl}`);
              console.log(`Expo Go URL: ${expoGoUrl}`);

              // Set GitHub Actions outputs
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `snack_id=${snackId}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `snack_url=${expoGoUrl}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `snack_web_url=${webUrl}\n`);

              return;
            }

            // Handle errors
            console.error('Failed to create Snack');
            if (result.errors) {
              console.error('Errors:', JSON.stringify(result.errors, null, 2));
            } else {
              console.error('Response:', JSON.stringify(result, null, 2));
            }
            process.exit(1);
          }

          createSnack();
          EOF

      - name: Notify Lumea (Success)
        if: success()
        run: |
          curl -X POST "${{ vars.LUMEA_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -H "X-Webhook-Secret: ${{ secrets.LUMEA_WEBHOOK_SECRET }}" \
            -d '{
              "projectId": "${{ inputs.lumea_project_id }}",
              "type": "mobile",
              "status": "ready",
              "snackUrl": "${{ steps.snack.outputs.snack_url }}",
              "snackWebUrl": "${{ steps.snack.outputs.snack_web_url }}",
              "snackId": "${{ steps.snack.outputs.snack_id }}",
              "commitSha": "${{ github.sha }}"
            }'

      - name: Notify Lumea (Failure)
        if: failure()
        run: |
          curl -X POST "${{ vars.LUMEA_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -H "X-Webhook-Secret: ${{ secrets.LUMEA_WEBHOOK_SECRET }}" \
            -d '{
              "projectId": "${{ inputs.lumea_project_id }}",
              "type": "mobile",
              "status": "error",
              "error": "Failed to create Snack",
              "commitSha": "${{ github.sha }}"
            }'

      - name: Summary
        if: success()
        run: |
          echo "## ðŸ“± Expo Snack Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Web URL:** ${{ steps.snack.outputs.snack_web_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Expo Go URL:** \`${{ steps.snack.outputs.snack_url }}\`" >> $GITHUB_STEP_SUMMARY
